Libraries

Библиотека или модуль — это набор готовых функций, объединённых общей темой.

Чтобы получить доступ к этим функциям, нужно в начале программы импортировать библиотеку командой import. Тогда в коде можно будет применять все функции, которые есть в библиотеке. 


import libraries_name


Часть функций не нуждаются в импорте, они встроены в Python и доступны без дополнительных манипуляций (print())

Если все функции библиотеки не нужны, можно импортировать только те, которые требуются: from random import choice  (из библиотеки random подключить функцию  choice).

В таком случае к этой функции обращаются напрямую, без указания имени библиотеки.

Иногда у библиотек очень длинные имена, и, если не хочется при каждом вызове писать её полное имя и загромождать код, при импорте можно дать библиотеке короткий «псевдоним» через ключевое слово as:

import libraries_name as alias_name

random

random.randint(min, max) выберет случайное целое число в диапазоне от числа min до числа max;
random.choice(список) вернёт случайный элемент из списка;
random.random() вернёт случайное дробное число от 0.0 до 1.0.

datatime

Для работы со временем в Python импортируют библиотеку datetime. 
В ней есть не только отдельные функции, но и целый новый тип данных — datetime.
Название типа данных точно совпадает с библиотекой, и это не слишком удобно.
Чтобы не путаться, библиотеку будем подключать под именем dt: 

import datetime as dt

Тип данных datetime — ещё один тип, как int, string или dict.
Он нужен, чтобы хранить информацию о конкретном моменте времени: год, месяц, день, час, минуты, секунды и микросекунды. 

Чтобы создать объект этого типа, нужно вызвать функцию datetime()  из библиотеки dt. 
Она принимает обязательные аргументы — год, месяц и день, — и необязательные: час, минута, секунда и микросекунда, которые по умолчанию равны нулю.

time_name = dt.datatime(1971, 4, 28, 16, 45 )

Тип данных datetime позволяет просто вычитать даты друг из друга, как обычные числа.

При создании данных типа datetime можно не указывать время и обойтись только датой. 
В этом случае метка времени будет установлена автоматически, это будет полночь, начало заданной даты.

У любой переменной типа данных datetime можно вызвать метод utcnow().
Он вернёт текущий момент времени по UTC с эталонной точностью до микросекунд.
 dt.datetime.utcnow()
 
нельзя складывать переменную типа datetime с переменной типа int

Тип данных timedelta, в котором можно сохранить определённый промежуток времени — в часах, днях, годах, как угодно. 
Этот тип данных тоже хранится в библиотеке dt. А объект такого типа создаётся функцией timedelta()

period = dt.timedelta(hours=3)

В аргументах функции timedelta() можно указывать days, hours, minutes, seconds, microseconds.

метод strftime(). Его можно применить к любому объекту типа datetime и аргументом задать формат вывода времени:

time_name.strftime('%H:%M')) 

Здесь %H означает часы, %M — минуты. 
Кроме этих параметров, бывают ещё, например %B  — месяц, %Y — год и %S — секунды, %A — название дня недели по-английски, %U — номер недели в году.


urllib.parse

Функция quote() из библиотеки urllib.parse умеет заменять символы, которые нельзя использовать по протоколу HTTP в URL на те, которые использовать можно. Но человеку такой адрес прочитать невозможно. 

string_code = urllib.parse.quote(string_name)
Например, в URL нельзя использовать символы кириллицы. И если нужно обратиться к адресу, который содержит кириллицу — кириллические символы нужно закодировать.
Например: 

    было Привет!,
    стало %D0%9F%D1%80%D0%B8%D0%B2%D0%B5%D1%82%21.

Компьютер такое поймёт, а вот человек уже нет. 
Для преобразования закодированных символов в обычные в той же библиотеке urllib.parse есть функция unquote(). Она конвертирует строку URL обратно в читаемый человеком формат.

string_uncode = urllib.parse.unquote(string_code)


requests

Общаться с серверами в интернете умеют не только браузеры. Можно написать собственный клиент на Python, используя библиотеку requests. Например, с помощью вашего первого программного веб-клиента можно отправить GET-запрос к  веб-сайту:

# Импортируем библиотеку:
import requests

# Отправляем GET-запрос:
response = requests.get('http://info.cern.ch/')

print(response.text)  # Печатаем код запрошенной страницы.

При запуске этой программы будет напечатан HTML-код запрошенной страницы.

Прямо из Python-кода, без браузера, мы отправили запрос к веб-странице http://info.cern.ch/, вызвав метод get(). И прямо в коде получили HTTP-ответ от сервера. 

HTTP-ответ представляет собой программный объект. Этот объект мы сохранили в переменную response. В свойстве text этого объекта хранится HTML-код запрошенной страницы. Чтобы распечатать код, мы передали  свойство response.text аргументом в функцию print().

Функция get() сама производит нужные преобразования, нужно лишь передать параметры через именованный аргумент params:

import requests

search_parameters = {
    'text': 'что такое backend',
    'lr': 213
}
url = 'https://yandex.ru/search/'
# Функция get() приняла на вход URL и параметры поиска,
# а дальше она знает, что делать
response = requests.get(url, params=search_parameters)

print(response.status_code)
print(response.url) 

Любимое число бэкендеров — это 200. Оно значит, что сервер всё понял и ответил как надо. 
Бывают такие параметры, которым не нужно присваивать значение, а достаточно передать только имя. 
Например, параметр u сервиса wttr.in переведёт все величины в английскую систему мер (градусы Фаренгейта, мили, дюймы): http://wttr.in/?u .
Для таких параметров в словаре в качестве значения указывается пустая строка.

import requests
    
        
parameters = {
    'u': '',
    'T': ''
}
url = 'http://wttr.in'

# параметры передаются через аргумент params
response = requests.get(url, params=parameters)

print(response.text) 

Заглянем в служебную информацию полученного HTTP-ответа:

import requests

response = requests.get('https://ya.ru/white')

# вот мы узнали, что код ответа 200 и заполучили это число в свой код:
code = response.status_code
print(f'Код ответа = {code}')

# а вот мы и заголовки читаем, и выводим их форматированной строкой
# с примечанием, каким захочется, на любом языке
headers = response.headers
print(f'Тип содержимого: {headers["content-type"]}')
print(f'Время ответа: {headers["date"]}')

Код ответа = 200
Тип содержимого: text/html; charset=UTF-8
Время ответа: Thu, 13 Jun 2019 15:25:13 GMT

Код HTTP-ответа (status_code) говорит о том, что запрошенная страница была возвращена успешно: 200 означает Ok.
Заголовки ответа доступны как словарь headers: по ключу — названию заголовка — доступно его значение.
Сетевой запрос может завершиться неуспехом, например:

response = requests.get('https://praktikum.yandex.ru/notfound')
print(response.status_code) 

Мы запросили страницу, которой нет в интернете, на что заслуженно получили в ответ код ошибки 404 Not found — «не найдено». Но и в браузере мы получили бы то же самое.

Заголовки есть не только у ответов, но и у запросов.
Когда вам понадобится передать заголовки в HTTP-запросе — соберите их в словаре, и передайте его как аргумент headers функции get():

import requests

request_headers = {
    'Accept-Language': 'ru'  # попросим материал на русском языке
}

# сходим почитать блоги про IT, строкой передаём URL платформы habr
response = requests.get('https://habr.com', headers=request_headers)

print(response.text)




